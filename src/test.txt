     1	mod data;
     2	mod processing;
     3	mod rendering;
     4	mod playback;
     5	mod ui;
     6	mod csv_export;
     7	
     8	use fltk::{
     9	    app,
    10	    button::Button,
    11	    enums::{Align, CallbackTrigger, Event, FrameType, Font, Key, Shortcut},
    12	    frame::Frame,
    13	    group::Flex,
    14	    input::{Input, FloatInput},
    15	    menu::{Choice, MenuBar, MenuFlag},
    16	    prelude::*,
    17	    valuator::{HorNiceSlider, HorSlider},
    18	    widget::Widget,
    19	    window::Window,
    20	    dialog,
    21	};
    22	
    23	use std::cell::{Cell, RefCell};
    24	use std::rc::Rc;
    25	use std::sync::{mpsc, Arc};
    26	use std::time::{Duration, Instant};
    27	
    28	use data::{AudioData, FftParams, Spectrogram, ViewState, FreqScale, ColormapId, TransportState, WindowType, TimeUnit};
    29	use processing::fft_engine::FftEngine;
    30	use processing::reconstructor::Reconstructor;
    31	use rendering::spectrogram_renderer::SpectrogramRenderer;
    32	use rendering::waveform_renderer::WaveformRenderer;
    33	use playback::audio_player::{AudioPlayer, PlaybackState};
    34	use ui::theme;
    35	use ui::tooltips::{TooltipManager, set_tooltip};
    36	
    37	// ─── Window Layout Constants ────────────────────────────────────────────────────
    38	const WIN_W: i32 = 1200;
    39	const WIN_H: i32 = 1200;
    40	const MENU_H: i32 = 25;
    41	const STATUS_H: i32 = 25;
    42	const SIDEBAR_W: i32 = 215;
    43	const SIDEBAR_INNER_W: i32 = 200;
    44	const SIDEBAR_INNER_H: i32 = 1100;
    45	
    46	// ─── Messages ──────────────────────────────────────────────────────────────────
    47	
    48	enum WorkerMessage {
    49	    FftComplete(Spectrogram),
    50	    ReconstructionComplete(AudioData),
    51	}
    52	
    53	// ─── App State ─────────────────────────────────────────────────────────────────
    54	
    55	struct AppState {
    56	    audio_data: Option<Arc<AudioData>>,
    57	    spectrogram: Option<Arc<Spectrogram>>,
    58	    fft_params: FftParams,
    59	    view: ViewState,
    60	    transport: TransportState,
    61	
    62	    audio_player: AudioPlayer,
    63	    spec_renderer: SpectrogramRenderer,
    64	    wave_renderer: WaveformRenderer,
    65	
    66	    reconstructed_audio: Option<AudioData>,
    67	    recon_start_time: f64,  // time offset of reconstructed audio within full file
    68	    is_processing: bool,
    69	    dirty: bool,            // true when settings changed and recompute needed
    70	    lock_to_active: bool,   // when true, viewport snaps to processing range on recompute
    71	    has_audio: bool,
    72	
    73	    tooltip_mgr: TooltipManager,
    74	}
    75	
    76	impl AppState {
    77	    fn new() -> Self {
    78	        Self {
    79	            audio_data: None,
    80	            spectrogram: None,
    81	            fft_params: FftParams::default(),
    82	            view: ViewState::default(),
    83	            transport: TransportState::default(),
    84	
    85	            audio_player: AudioPlayer::new(),
    86	            spec_renderer: SpectrogramRenderer::new(),
    87	            wave_renderer: WaveformRenderer::new(),
    88	
    89	            reconstructed_audio: None,
    90	            recon_start_time: 0.0,
    91	            is_processing: false,
    92	            dirty: false,
    93	            lock_to_active: false,
    94	            has_audio: false,
    95	
    96	            tooltip_mgr: TooltipManager::new(),
    97	        }
    98	    }
    99	
   100	    /// Compute all derived info values from current params
   101	    fn derived_info(&self) -> DerivedInfo {
   102	        let total_samples = if let Some(ref audio) = self.audio_data {
   103	            let start = self.fft_params.start_sample().min(audio.num_samples());
   104	            let stop = self.fft_params.stop_sample().min(audio.num_samples());
   105	            stop.saturating_sub(start)
   106	        } else {
   107	            0
   108	        };
   109	
   110	        let freq_bins = self.fft_params.num_frequency_bins();
   111	        let freq_res = self.fft_params.frequency_resolution();
   112	        let hop = self.fft_params.hop_length();
   113	        let segments = self.fft_params.num_segments(total_samples);
   114	        let bin_duration_ms = self.fft_params.bin_duration_seconds() * 1000.0;
   115	
   116	        DerivedInfo {
   117	            total_samples,
   118	            freq_bins,
   119	            freq_resolution: freq_res,
   120	            hop_length: hop,
   121	            segments,
   122	            bin_duration_ms,
   123	            window_length: self.fft_params.window_length,
   124	        }
   125	    }
   126	}
   127	
   128	struct DerivedInfo {
   129	    total_samples: usize,
   130	    freq_bins: usize,
   131	    freq_resolution: f32,
   132	    hop_length: usize,
   133	    segments: usize,
   134	    bin_duration_ms: f64,
   135	    window_length: usize,
   136	}
   137	
   138	impl DerivedInfo {
   139	    fn format_info(&self) -> String {
   140	        format!(
   141	            "Segments: {}\nSamples: {}\nFreq bins: {}\nFreq res: {:.2} Hz\nHop: {} smp\nBin dur: {:.2} ms\nWindow: {} smp",
   142	            self.segments, self.total_samples, self.freq_bins,
   143	            self.freq_resolution, self.hop_length, self.bin_duration_ms,
   144	            self.window_length
   145	        )
   146	    }
   147	}
   148	
   149	/// Throttle helper to prevent excessive redraws
   150	struct UpdateThrottle {
   151	    last_update: Instant,
   152	    min_interval: Duration,
   153	}
   154	
   155	impl UpdateThrottle {
   156	    fn new(min_interval_ms: u64) -> Self {
   157	        Self {
   158	            last_update: Instant::now() - Duration::from_millis(min_interval_ms + 1),
   159	            min_interval: Duration::from_millis(min_interval_ms),
   160	        }
   161	    }
   162	
   163	    fn should_update(&mut self) -> bool {
   164	        let now = Instant::now();
   165	        if now.duration_since(self.last_update) >= self.min_interval {
   166	            self.last_update = now;
   167	            true
   168	        } else {
   169	            false
   170	        }
   171	    }
   172	}
   173	
   174	// ─── Format time as M:SS.ms ───────────────────────────────────────────────────
   175	
   176	fn format_time(seconds: f64) -> String {
   177	    let mins = (seconds / 60.0) as u32;
   178	    let secs = seconds % 60.0;
   179	    format!("{}:{:05.2}", mins, secs)
   180	}
   181	
   182	// ─── Float/Int Input Validation ──────────────────────────────────────────────
   183	//
   184	// Revert-based validation: let the character enter, then validate and revert
   185	// if invalid. This works on VNC/Termux/remote desktop where keystroke blocking
   186	// doesn't work because input arrives as Shortcut/Paste events.
   187	
   188	fn is_valid_float_input(text: &str) -> bool {
   189	    let digits = text.strip_prefix('-').unwrap_or(text);
   190	    if digits.is_empty() { return true; }
   191	    if digits.starts_with('.') { return false; }
   192	    let parts: Vec<&str> = digits.split('.').collect();
   193	    parts.len() <= 2 && parts.iter().all(|p| p.is_empty() || p.chars().all(|c| c.is_ascii_digit()))
   194	}
   195	
   196	fn is_valid_uint_input(text: &str) -> bool {
   197	    text.is_empty() || text.chars().all(|c| c.is_ascii_digit())
   198	}
   199	
   200	fn attach_float_validation(input: &mut FloatInput) {
   201	    let mut last_valid = String::new();
   202	    input.set_trigger(CallbackTrigger::Changed);
   203	    input.set_callback(move |field| {
   204	        let current = field.value();
   205	        let minus_just_added = current.contains('-') && !last_valid.contains('-');
   206	        let typed_at_start = field.position() == 1;
   207	        if is_valid_float_input(&current) && !(minus_just_added && !typed_at_start) {
   208	            last_valid = current;
   209	        } else {
   210	            let restore = field.position().saturating_sub(1);
   211	            field.set_value(&last_valid);
   212	            field.set_position(restore).ok();
   213	        }
   214	    });
   215	}
   216	
   217	fn attach_uint_validation(input: &mut Input) {
   218	    let mut last_valid = String::new();
   219	    input.set_trigger(CallbackTrigger::Changed);
   220	    input.set_callback(move |field| {
   221	        let current = field.value();
   222	        if is_valid_uint_input(&current) {
   223	            last_valid = current;
   224	        } else {
   225	            let restore = field.position().saturating_sub(1);
   226	            field.set_value(&last_valid);
   227	            field.set_position(restore).ok();
   228	        }
   229	    });
   230	}
   231	
   232	// Helper: parse a field value as f64, treating empty as 0
   233	fn parse_or_zero_f64(s: &str) -> f64 {
   234	    if s.is_empty() { 0.0 } else { s.parse().unwrap_or(0.0) }
   235	}
   236	
   237	fn parse_or_zero_usize(s: &str) -> usize {
   238	    if s.is_empty() { 0 } else { s.parse().unwrap_or(0) }
   239	}
   240	
   241	fn parse_or_zero_f32(s: &str) -> f32 {
   242	    if s.is_empty() { 0.0 } else { s.parse().unwrap_or(0.0) }
   243	}
   244	
   245	// ─── MAIN ──────────────────────────────────────────────────────────────────────
   246	
   247	fn main() {
   248	    let app = app::App::default();
   249	
   250	    // Apply dark theme
   251	    theme::apply_dark_theme();
   252	    app::set_visual(fltk::enums::Mode::Rgb8).ok();
   253	
   254	    let mut win = Window::new(50, 50, WIN_W, WIN_H, "muSickBeets FFT Analyzer");
   255	    win.make_resizable(true);
   256	    win.set_color(theme::color(theme::BG_DARK));
   257	
   258	    let state = Rc::new(RefCell::new(AppState::new()));
   259	    let (tx, rx) = mpsc::channel::<WorkerMessage>();
   260	
   261	    // ═══════════════════════════════════════════════════════════════════════════
   262	    //  MENU BAR
   263	    // ═══════════════════════════════════════════════════════════════════════════
   264	
   265	    let mut menu = MenuBar::default().with_size(WIN_W, MENU_H);
   266	    menu.set_color(theme::color(theme::BG_PANEL));
   267	    menu.set_text_color(theme::color(theme::TEXT_PRIMARY));
   268	    menu.set_text_size(12);
   269	
   270	    // Menu items will be wired via callbacks after layout
   271	
   272	    // ═══════════════════════════════════════════════════════════════════════════
   273	    //  ROOT LAYOUT (below menu bar)
   274	    // ═══════════════════════════════════════════════════════════════════════════
   275	
   276	    let mut root = Flex::default()
   277	        .with_pos(0, MENU_H)
   278	        .with_size(WIN_W, WIN_H - MENU_H - STATUS_H)
   279	        .row();
   280	
   281	    // ─── LEFT PANEL (Controls) ─────────────────────────────────────────────────
   282	
   283	    let mut left_scroll = fltk::group::Scroll::default();
   284	    left_scroll.set_color(theme::color(theme::BG_PANEL));
   285	    root.fixed(&left_scroll, SIDEBAR_W);
   286	
   287	    let mut left = Flex::default()
   288	        .with_size(SIDEBAR_INNER_W, SIDEBAR_INNER_H)  // tall enough for all controls
   289	        .column();
   290	    left.set_margin(5);
   291	    left.set_pad(2);
   292	
   293	    // ── Title ──
   294	    let mut title = Frame::default().with_label("FFT Analyzer");
   295	    title.set_label_size(15);
   296	    title.set_label_color(theme::color(theme::ACCENT_BLUE));
   297	    left.fixed(&title, 28);
   298	
   299	    // ════════════════════════════════════════════════════════════════
   300	    //  SECTION: File Operations
   301	    // ════════════════════════════════════════════════════════════════
   302	
   303	    let mut lbl_file = Frame::default().with_label("FILE");
   304	    lbl_file.set_label_color(theme::section_header_color());
   305	    lbl_file.set_label_size(11);
   306	    lbl_file.set_align(Align::Inside | Align::Left);
   307	    left.fixed(&lbl_file, 18);
   308	
   309	    let mut btn_open = Button::default().with_label("Open Audio File");
   310	    btn_open.set_color(theme::color(theme::BG_WIDGET));
   311	    btn_open.set_label_color(theme::color(theme::TEXT_PRIMARY));
   312	    set_tooltip(&mut btn_open, "Open a WAV audio file for analysis.\nSupports 8/16/24/32-bit PCM and float formats.");
   313	    left.fixed(&btn_open, 28);
   314	
   315	    let mut btn_save_fft = Button::default().with_label("Save FFT Data");
   316	    btn_save_fft.set_color(theme::color(theme::BG_WIDGET));
   317	    btn_save_fft.set_label_color(theme::color(theme::TEXT_PRIMARY));
   318	    btn_save_fft.deactivate();
   319	    set_tooltip(&mut btn_save_fft, "Export spectrogram data to CSV.\nRequires FFT data to be computed first.");
   320	    left.fixed(&btn_save_fft, 28);
   321	
   322	    let mut btn_load_fft = Button::default().with_label("Load FFT Data");
   323	    btn_load_fft.set_color(theme::color(theme::BG_WIDGET));
   324	    btn_load_fft.set_label_color(theme::color(theme::TEXT_PRIMARY));
   325	    set_tooltip(&mut btn_load_fft, "Import previously saved FFT data from CSV.");
   326	    left.fixed(&btn_load_fft, 28);
   327	
   328	    let mut btn_save_wav = Button::default().with_label("Export WAV");
   329	    btn_save_wav.set_color(theme::color(theme::BG_WIDGET));
   330	    btn_save_wav.set_label_color(theme::color(theme::TEXT_PRIMARY));
   331	    btn_save_wav.deactivate();
   332	    set_tooltip(&mut btn_save_wav, "Save reconstructed audio as 16-bit WAV.\nReconstruct audio first, then export.");
   333	    left.fixed(&btn_save_wav, 28);
   334	
   335	    // Separator
   336	    let mut sep1 = Frame::default();
   337	    sep1.set_frame(FrameType::FlatBox);
   338	    sep1.set_color(theme::color(theme::SEPARATOR));
   339	    left.fixed(&sep1, 1);
   340	
   341	    // ════════════════════════════════════════════════════════════════
   342	    //  SECTION: Analysis Parameters
   343	    // ════════════════════════════════════════════════════════════════
   344	
   345	    let mut lbl_analysis = Frame::default().with_label("ANALYSIS");
   346	    lbl_analysis.set_label_color(theme::section_header_color());
   347	    lbl_analysis.set_label_size(11);
   348	    lbl_analysis.set_align(Align::Inside | Align::Left);
   349	    left.fixed(&lbl_analysis, 18);
   350	
   351	    // Time range
   352	    let mut btn_time_unit = Button::default().with_label("Unit: Seconds");
   353	    btn_time_unit.set_color(theme::color(theme::BG_WIDGET));
   354	    btn_time_unit.set_label_color(theme::color(theme::TEXT_PRIMARY));
   355	    btn_time_unit.set_label_size(11);
   356	    btn_time_unit.deactivate();
   357	    set_tooltip(&mut btn_time_unit, "Toggle between Seconds and Samples.\nClicking converts the start/stop values.");
   358	    left.fixed(&btn_time_unit, 25);
   359	
   360	    let mut input_start = FloatInput::default().with_label("Start:");
   361	    input_start.set_value("0");
   362	    input_start.set_color(theme::color(theme::BG_WIDGET));
   363	    input_start.set_text_color(theme::color(theme::TEXT_PRIMARY));
   364	    input_start.deactivate();
   365	    set_tooltip(&mut input_start, "Analysis start position.\nFunctional range: 0 to audio duration.\nYou can go outside this range if you want.");
   366	    attach_float_validation(&mut input_start);
   367	    left.fixed(&input_start, 25);
   368	
   369	    let mut input_stop = FloatInput::default().with_label("Stop:");
   370	    input_stop.set_value("0");
   371	    input_stop.set_color(theme::color(theme::BG_WIDGET));
   372	    input_stop.set_text_color(theme::color(theme::TEXT_PRIMARY));
   373	    input_stop.deactivate();
   374	    set_tooltip(&mut input_stop, "Analysis stop position.\nFunctional range: 0 to audio duration.\nYou can go outside this range if you want.");
   375	    attach_float_validation(&mut input_stop);
   376	    left.fixed(&input_stop, 25);
   377	
   378	    // Window length (segments) with +/- buttons
   379	    let mut lbl_wl = Frame::default().with_label("Segment Size:");
   380	    lbl_wl.set_label_color(theme::color(theme::TEXT_SECONDARY));
   381	    lbl_wl.set_label_size(11);
   382	    lbl_wl.set_align(Align::Inside | Align::Left);
   383	    left.fixed(&lbl_wl, 16);
   384	
   385	    let mut seg_row = Flex::default().row();
   386	    seg_row.set_pad(2);
   387	
   388	    let mut btn_seg_minus = Button::default().with_label("-");
   389	    btn_seg_minus.set_color(theme::color(theme::BG_WIDGET));
   390	    btn_seg_minus.set_label_color(theme::color(theme::TEXT_PRIMARY));
   391	    btn_seg_minus.set_label_size(14);
   392	    btn_seg_minus.deactivate();
   393	    set_tooltip(&mut btn_seg_minus, "Halve the segment size.\nSmaller segments = better time resolution, worse frequency resolution.");
   394	    seg_row.fixed(&btn_seg_minus, 30);
   395	
   396	    let mut btn_seg_plus = Button::default().with_label("+");
   397	    btn_seg_plus.set_color(theme::color(theme::BG_WIDGET));
   398	    btn_seg_plus.set_label_color(theme::color(theme::TEXT_PRIMARY));
   399	    btn_seg_plus.set_label_size(14);
   400	    btn_seg_plus.deactivate();
   401	    set_tooltip(&mut btn_seg_plus, "Double the segment size.\nLarger segments = better frequency resolution, worse time resolution.");
   402	    seg_row.fixed(&btn_seg_plus, 30);
   403	
   404	    let mut lbl_seg_value = Frame::default().with_label("2048 smp / 42.67 ms");
   405	    lbl_seg_value.set_label_color(theme::color(theme::TEXT_PRIMARY));
   406	    lbl_seg_value.set_label_size(10);
   407	    lbl_seg_value.set_align(Align::Inside | Align::Left);
   408	
   409	    seg_row.end();
   410	    left.fixed(&seg_row, 25);
   411	
   412	    // Overlap
   413	    let mut slider_overlap = HorNiceSlider::default();
   414	    slider_overlap.set_minimum(0.0);
   415	    slider_overlap.set_maximum(95.0);
   416	    slider_overlap.set_value(75.0);
   417	    slider_overlap.set_color(theme::color(theme::BG_WIDGET));
   418	    slider_overlap.set_selection_color(theme::accent_color());
   419	    slider_overlap.deactivate();
   420	    set_tooltip(&mut slider_overlap, "Overlap between adjacent FFT windows.\nFunctional range: 0% to 95%.\nHigher = more time frames, smoother spectrogram.\n75% is standard for Hann window.");
   421	    left.fixed(&slider_overlap, 22);
   422	
   423	    let mut lbl_overlap_val = Frame::default().with_label("Overlap: 75%");
   424	    lbl_overlap_val.set_label_color(theme::color(theme::TEXT_SECONDARY));
   425	    lbl_overlap_val.set_label_size(11);
   426	    lbl_overlap_val.set_align(Align::Inside | Align::Right);
   427	    left.fixed(&lbl_overlap_val, 14);
   428	
   429	    // Window type
   430	    let mut window_type_choice = Choice::default();
   431	    window_type_choice.add_choice("Hann");
   432	    window_type_choice.add_choice("Hamming");
   433	    window_type_choice.add_choice("Blackman");
   434	    window_type_choice.add_choice("Kaiser");
   435	    window_type_choice.set_value(0);
   436	    window_type_choice.set_color(theme::color(theme::BG_WIDGET));
   437	    window_type_choice.set_text_color(theme::color(theme::TEXT_PRIMARY));
   438	    window_type_choice.deactivate();
   439	    set_tooltip(&mut window_type_choice, "Windowing function applied to each FFT segment.\nHann: general purpose, good frequency resolution.\nHamming: slightly better sidelobe rejection.\nBlackman: best sidelobe rejection, wider main lobe.\nKaiser: configurable via beta parameter.");
   440	    left.fixed(&window_type_choice, 25);
   441	
   442	    let mut input_kaiser_beta = FloatInput::default().with_label("Kaiser B:");
   443	    input_kaiser_beta.set_value("8.6");
   444	    input_kaiser_beta.set_color(theme::color(theme::BG_WIDGET));
   445	    input_kaiser_beta.set_text_color(theme::color(theme::TEXT_PRIMARY));
   446	    input_kaiser_beta.deactivate();
   447	    set_tooltip(&mut input_kaiser_beta, "Kaiser window beta parameter.\nFunctional range: 0.0 to 20.0.\nHigher = narrower main lobe, higher sidelobes.\n8.6 approximates a Blackman window.");
   448	    left.fixed(&input_kaiser_beta, 25);
   449	
   450	    let mut check_center = fltk::button::CheckButton::default().with_label(" Center/Pad");
   451	    check_center.set_checked(true);
   452	    check_center.set_label_color(theme::color(theme::TEXT_PRIMARY));
   453	    check_center.deactivate();
   454	    set_tooltip(&mut check_center, "Add zero-padding around signal for symmetric analysis.\nRecommended: ON for most use cases.");
   455	    left.fixed(&check_center, 22);
   456	
   457	    let mut btn_rerun = Button::default().with_label("Recompute + Rebuild (Space)");
   458	    btn_rerun.set_color(theme::color(theme::ACCENT_BLUE));
   459	    btn_rerun.set_label_color(theme::color(theme::BG_DARK));
   460	    btn_rerun.set_label_size(11);
   461	    btn_rerun.deactivate();
   462	    set_tooltip(&mut btn_rerun, "Rerun FFT + reconstruct audio with current parameters.\nShortcut: Spacebar (works from anywhere).\nAll outputs (spectrogram, waveform, audio) will update.");
   463	    left.fixed(&btn_rerun, 28);
   464	
   465	    // Separator
   466	    let mut sep2 = Frame::default();
   467	    sep2.set_frame(FrameType::FlatBox);
   468	    sep2.set_color(theme::color(theme::SEPARATOR));
   469	    left.fixed(&sep2, 1);
   470	
   471	    // ════════════════════════════════════════════════════════════════
   472	    //  SECTION: Display
   473	    // ════════════════════════════════════════════════════════════════
   474	
   475	    let mut lbl_display = Frame::default().with_label("DISPLAY");
   476	    lbl_display.set_label_color(theme::section_header_color());
   477	    lbl_display.set_label_size(11);
   478	    lbl_display.set_align(Align::Inside | Align::Left);
   479	    left.fixed(&lbl_display, 18);
   480	
   481	    // Colormap
   482	    let mut colormap_choice = Choice::default();
   483	    for cm in ColormapId::ALL {
   484	        colormap_choice.add_choice(cm.name());
   485	    }
   486	    colormap_choice.set_value(0);
   487	    colormap_choice.set_color(theme::color(theme::BG_WIDGET));
   488	    colormap_choice.set_text_color(theme::color(theme::TEXT_PRIMARY));
   489	    set_tooltip(&mut colormap_choice, "Color scheme for the spectrogram display.\nClassic: blue-cyan-green-yellow-red (rainbow)\nViridis/Magma/Inferno: perceptually uniform scientific colormaps\nGreyscale: black to white\nInverted Grey: white to black (print-friendly)");
   490	    left.fixed(&colormap_choice, 25);
   491	
   492	    // Scale toggle
   493	    let mut scale_choice = Choice::default();
   494	    scale_choice.add_choice("Log Frequency");
   495	    scale_choice.add_choice("Linear Frequency");
   496	    scale_choice.set_value(0);
   497	    scale_choice.set_color(theme::color(theme::BG_WIDGET));
   498	    scale_choice.set_text_color(theme::color(theme::TEXT_PRIMARY));
   499	    set_tooltip(&mut scale_choice, "Frequency axis scaling.\nLog: musical/perceptual spacing (recommended).\n  Octaves get equal visual space.\nLinear: uniform Hz spacing.\n  High frequencies dominate the display.");
   500	    left.fixed(&scale_choice, 25);
   501	
   502	    // Threshold
   503	    let mut slider_threshold = HorNiceSlider::default();
   504	    slider_threshold.set_minimum(-120.0);
   505	    slider_threshold.set_maximum(0.0);
   506	    slider_threshold.set_value(-80.0);
   507	    slider_threshold.set_color(theme::color(theme::BG_WIDGET));
   508	    slider_threshold.set_selection_color(theme::accent_color());
   509	    set_tooltip(&mut slider_threshold, "Minimum dB level to display.\nFunctional range: -120 dB to 0 dB.\nAnything below this threshold appears as background color.\nLower = show more quiet detail. Higher = focus on loud content.");
   510	    left.fixed(&slider_threshold, 22);
   511	
   512	    let mut lbl_threshold_val = Frame::default().with_label("Threshold: -80 dB");
   513	    lbl_threshold_val.set_label_color(theme::color(theme::TEXT_SECONDARY));
   514	    lbl_threshold_val.set_label_size(11);
   515	    lbl_threshold_val.set_align(Align::Inside | Align::Right);
   516	    left.fixed(&lbl_threshold_val, 14);
   517	
   518	    // Brightness
   519	    let mut slider_brightness = HorNiceSlider::default();
   520	    slider_brightness.set_minimum(0.1);
   521	    slider_brightness.set_maximum(3.0);
   522	    slider_brightness.set_value(1.0);
   523	    slider_brightness.set_color(theme::color(theme::BG_WIDGET));
   524	    slider_brightness.set_selection_color(theme::accent_color());
   525	    set_tooltip(&mut slider_brightness, "Overall brightness multiplier.\nFunctional range: 0.1 to 3.0.\n1.0 = neutral. Higher = brighter colors for quiet content.");
   526	    left.fixed(&slider_brightness, 22);
   527	
   528	    let mut lbl_brightness_val = Frame::default().with_label("Brightness: 1.0");
   529	    lbl_brightness_val.set_label_color(theme::color(theme::TEXT_SECONDARY));
   530	    lbl_brightness_val.set_label_size(11);
   531	    lbl_brightness_val.set_align(Align::Inside | Align::Right);
   532	    left.fixed(&lbl_brightness_val, 14);
   533	
   534	    // Gamma
   535	    let mut slider_gamma = HorNiceSlider::default();
   536	    slider_gamma.set_minimum(0.5);
   537	    slider_gamma.set_maximum(5.0);
   538	    slider_gamma.set_value(2.2);
   539	    slider_gamma.set_color(theme::color(theme::BG_WIDGET));
   540	    slider_gamma.set_selection_color(theme::accent_color());
   541	    set_tooltip(&mut slider_gamma, "Perceptual gamma correction for dB display.\nFunctional range: 0.5 to 5.0.\n2.2 = standard perceptual gamma (recommended).\nHigher = more contrast, quiet content less visible.\nLower = flatter, quiet content more visible.");
   542	    left.fixed(&slider_gamma, 22);
   543	
   544	    let mut lbl_gamma_val = Frame::default().with_label("Gamma: 2.2");
   545	    lbl_gamma_val.set_label_color(theme::color(theme::TEXT_SECONDARY));
   546	    lbl_gamma_val.set_label_size(11);
   547	    lbl_gamma_val.set_align(Align::Inside | Align::Right);
   548	    left.fixed(&lbl_gamma_val, 14);
   549	
   550	    // Separator
   551	    let mut sep3 = Frame::default();
   552	    sep3.set_frame(FrameType::FlatBox);
   553	    sep3.set_color(theme::color(theme::SEPARATOR));
   554	    left.fixed(&sep3, 1);
   555	
   556	    // ════════════════════════════════════════════════════════════════
   557	    //  SECTION: Reconstruction
   558	    // ════════════════════════════════════════════════════════════════
   559	
   560	    let mut lbl_recon = Frame::default().with_label("RECONSTRUCTION");
   561	    lbl_recon.set_label_color(theme::section_header_color());
   562	    lbl_recon.set_label_size(11);
   563	    lbl_recon.set_align(Align::Inside | Align::Left);
   564	    left.fixed(&lbl_recon, 18);
   565	
   566	    // Frequency count
   567	    let mut lbl_fc = Frame::default().with_label("Freq Count:");
   568	    lbl_fc.set_label_color(theme::color(theme::TEXT_SECONDARY));
   569	    lbl_fc.set_label_size(11);
   570	    lbl_fc.set_align(Align::Inside | Align::Left);
   571	    left.fixed(&lbl_fc, 16);
   572	
   573	    let mut input_freq_count = Input::default();
   574	    input_freq_count.set_value("1025");
   575	    input_freq_count.set_color(theme::color(theme::BG_WIDGET));
   576	    input_freq_count.set_text_color(theme::color(theme::TEXT_PRIMARY));
   577	    input_freq_count.deactivate();
   578	    set_tooltip(&mut input_freq_count, "Number of top-magnitude frequency bins to keep per frame.\nFunctional range: 1 to max bins (shown in INFO).\nMax = perfect reconstruction. Lower = simplified/filtered sound.\nAt 1, only the loudest frequency per frame is reconstructed.");
   579	    attach_uint_validation(&mut input_freq_count);
   580	    left.fixed(&input_freq_count, 25);
   581	
   582	    // Frequency range
   583	    let mut lbl_freq_min = Frame::default().with_label("Recon Min Freq (Hz):");
   584	    lbl_freq_min.set_label_color(theme::color(theme::TEXT_SECONDARY));
   585	    lbl_freq_min.set_label_size(11);
   586	    lbl_freq_min.set_align(Align::Inside | Align::Left);
   587	    left.fixed(&lbl_freq_min, 16);
   588	
   589	    let mut input_recon_freq_min = FloatInput::default();
   590	    input_recon_freq_min.set_value("0");
   591	    input_recon_freq_min.set_color(theme::color(theme::BG_WIDGET));
   592	    input_recon_freq_min.set_text_color(theme::color(theme::TEXT_PRIMARY));
   593	    input_recon_freq_min.deactivate();
   594	    set_tooltip(&mut input_recon_freq_min, "Minimum frequency for reconstruction.\nFunctional range: 0 to Nyquist.\nBins below this frequency are zeroed out.");
   595	    attach_float_validation(&mut input_recon_freq_min);
   596	    left.fixed(&input_recon_freq_min, 25);
   597	
   598	    let mut lbl_freq_max = Frame::default().with_label("Recon Max Freq (Hz):");
   599	    lbl_freq_max.set_label_color(theme::color(theme::TEXT_SECONDARY));
   600	    lbl_freq_max.set_label_size(11);
   601	    lbl_freq_max.set_align(Align::Inside | Align::Left);
   602	    left.fixed(&lbl_freq_max, 16);
   603	
   604	    let mut input_recon_freq_max = FloatInput::default();
   605	    input_recon_freq_max.set_value("24000");
   606	    input_recon_freq_max.set_color(theme::color(theme::BG_WIDGET));
   607	    input_recon_freq_max.set_text_color(theme::color(theme::TEXT_PRIMARY));
   608	    input_recon_freq_max.deactivate();
   609	    set_tooltip(&mut input_recon_freq_max, "Maximum frequency for reconstruction.\nFunctional range: 0 to Nyquist.\nBins above this frequency are zeroed out.");
   610	    attach_float_validation(&mut input_recon_freq_max);
   611	    left.fixed(&input_recon_freq_max, 25);
   612	
   613	    // Snap viewport to processing window
   614	    let mut btn_snap_to_view = Button::default().with_label("Snap to View");
   615	    btn_snap_to_view.set_color(theme::color(theme::BG_WIDGET));
   616	    btn_snap_to_view.set_label_color(theme::color(theme::TEXT_PRIMARY));
   617	    btn_snap_to_view.set_label_size(11);
   618	    btn_snap_to_view.deactivate();
   619	    set_tooltip(&mut btn_snap_to_view, "Copy current viewport bounds into\nStart/Stop and Freq Min/Max fields.\nThen recompute.");
   620	    left.fixed(&btn_snap_to_view, 25);
   621	
   622	    // Separator
   623	    let mut sep4 = Frame::default();
   624	    sep4.set_frame(FrameType::FlatBox);
   625	    sep4.set_color(theme::color(theme::SEPARATOR));
   626	    left.fixed(&sep4, 1);
   627	
   628	    // ════════════════════════════════════════════════════════════════
   629	    //  SECTION: Info Panel (read-only)
   630	    // ════════════════════════════════════════════════════════════════
   631	
   632	    let mut lbl_info_header = Frame::default().with_label("INFO");
   633	    lbl_info_header.set_label_color(theme::section_header_color());
   634	    lbl_info_header.set_label_size(11);
   635	    lbl_info_header.set_align(Align::Inside | Align::Left);
   636	    left.fixed(&lbl_info_header, 18);
   637	
   638	    let mut lbl_info = Frame::default().with_label("No audio loaded");
   639	    lbl_info.set_label_color(theme::color(theme::TEXT_SECONDARY));
   640	    lbl_info.set_label_size(10);
   641	    lbl_info.set_align(Align::Inside | Align::Left | Align::Top);
   642	    left.fixed(&lbl_info, 110);
   643	
   644	    // Separator
   645	    let mut sep5 = Frame::default();
   646	    sep5.set_frame(FrameType::FlatBox);
   647	    sep5.set_color(theme::color(theme::SEPARATOR));
   648	    left.fixed(&sep5, 1);
   649	
   650	    // Tooltip toggle
   651	    let mut btn_tooltips = fltk::button::CheckButton::default().with_label(" Show Tooltips");
   652	    btn_tooltips.set_checked(true);
   653	    btn_tooltips.set_label_color(theme::color(theme::TEXT_SECONDARY));
   654	    btn_tooltips.set_label_size(10);
   655	    set_tooltip(&mut btn_tooltips, "Toggle tooltip help bubbles on/off.");
   656	    left.fixed(&btn_tooltips, 22);
   657	
   658	    // Lock viewport to active area toggle
   659	    let mut check_lock_active = fltk::button::CheckButton::default().with_label(" Lock to Active");
   660	    check_lock_active.set_checked(false);
   661	    check_lock_active.set_label_color(theme::color(theme::TEXT_SECONDARY));
   662	    check_lock_active.set_label_size(10);
   663	    set_tooltip(&mut check_lock_active, "When checked, viewport auto-snaps to\nthe processing time range on recompute.");
   664	    left.fixed(&check_lock_active, 22);
   665	
   666	    // Home button — snap viewport to processing range
   667	    let mut btn_home = Button::default().with_label("Home");
   668	    btn_home.set_color(theme::color(theme::BG_WIDGET));
   669	    btn_home.set_label_color(theme::color(theme::TEXT_PRIMARY));
   670	    btn_home.set_label_size(11);
   671	    set_tooltip(&mut btn_home, "Snap viewport to the active processing\ntime range (sidebar Start/Stop).");
   672	    left.fixed(&btn_home, 25);
   673	
   674	    // Spacer to push everything up
   675	    Frame::default();
   676	
   677	    left.end();
   678	    left_scroll.end();
   679	
   680	    // ─── RIGHT PANEL (Display area) ────────────────────────────────────────────
   681	
   682	    let mut right = Flex::default().column();
   683	    right.set_margin(2);
   684	    right.set_pad(2);
   685	
   686	    // ── Waveform strip ──
   687	    let mut waveform_display = Widget::default();
   688	    waveform_display.set_frame(FrameType::FlatBox);
   689	    waveform_display.set_color(theme::color(theme::BG_DARK));
   690	    right.fixed(&waveform_display, 100);
   691	
   692	    // ── Spectrogram area (with Y scrollbar) ──
   693	    let mut spec_row = Flex::default().row();
   694	
   695	    // Frequency axis label area
   696	    let mut freq_axis = Widget::default();
   697	    freq_axis.set_frame(FrameType::FlatBox);
   698	    freq_axis.set_color(theme::color(theme::BG_DARK));
   699	    spec_row.fixed(&freq_axis, 50);
   700	
   701	    // Main spectrogram display
   702	    let mut spec_display = Widget::default();
   703	    spec_display.set_frame(FrameType::FlatBox);
   704	    spec_display.set_color(theme::color(theme::BG_DARK));
   705	
   706	    // Y-axis controls (freq zoom +/- and scrollbar)
   707	    let mut freq_zoom_col = Flex::default().column();
   708	    freq_zoom_col.set_pad(1);
   709	
   710	    let mut btn_freq_zoom_in = Button::default().with_label("+");
   711	    btn_freq_zoom_in.set_color(theme::color(theme::BG_WIDGET));
   712	    btn_freq_zoom_in.set_label_color(theme::color(theme::TEXT_PRIMARY));
   713	    btn_freq_zoom_in.set_label_size(12);
   714	    set_tooltip(&mut btn_freq_zoom_in, "Zoom in on frequency axis.");
   715	    freq_zoom_col.fixed(&btn_freq_zoom_in, 20);
   716	
   717	    let mut y_scroll = fltk::valuator::Scrollbar::default();
   718	    y_scroll.set_type(fltk::valuator::ScrollbarType::Vertical);
   719	    y_scroll.set_color(theme::color(theme::BG_WIDGET));
   720	    y_scroll.set_selection_color(theme::accent_color());
   721	    set_tooltip(&mut y_scroll, "Frequency axis pan.\nDrag to scroll up/down.");
   722	
   723	    let mut btn_freq_zoom_out = Button::default().with_label("-");
   724	    btn_freq_zoom_out.set_color(theme::color(theme::BG_WIDGET));
   725	    btn_freq_zoom_out.set_label_color(theme::color(theme::TEXT_PRIMARY));
   726	    btn_freq_zoom_out.set_label_size(12);
   727	    set_tooltip(&mut btn_freq_zoom_out, "Zoom out on frequency axis.");
   728	    freq_zoom_col.fixed(&btn_freq_zoom_out, 20);
   729	
   730	    freq_zoom_col.end();
   731	    spec_row.fixed(&freq_zoom_col, 20);
   732	
   733	    spec_row.end();
   734	
   735	    // ── Time axis label area ──
   736	    let mut time_axis = Widget::default();
   737	    time_axis.set_frame(FrameType::FlatBox);
   738	    time_axis.set_color(theme::color(theme::BG_DARK));
   739	    right.fixed(&time_axis, 20);
   740	
   741	    // ── X-axis controls (time zoom +/- and scrollbar) ──
   742	    let mut time_zoom_row = Flex::default().row();
   743	    time_zoom_row.set_pad(1);
   744	
   745	    let mut btn_time_zoom_out = Button::default().with_label("-");
   746	    btn_time_zoom_out.set_color(theme::color(theme::BG_WIDGET));
   747	    btn_time_zoom_out.set_label_color(theme::color(theme::TEXT_PRIMARY));
   748	    btn_time_zoom_out.set_label_size(12);
   749	    set_tooltip(&mut btn_time_zoom_out, "Zoom out on time axis.");
   750	    time_zoom_row.fixed(&btn_time_zoom_out, 20);
   751	
   752	    let mut x_scroll = fltk::valuator::Scrollbar::default();
   753	    x_scroll.set_type(fltk::valuator::ScrollbarType::Horizontal);
   754	    x_scroll.set_color(theme::color(theme::BG_WIDGET));
   755	    x_scroll.set_selection_color(theme::accent_color());
   756	    set_tooltip(&mut x_scroll, "Time axis pan.\nDrag to scroll left/right.\nMouse wheel on spectrogram to zoom.");
   757	
   758	    let mut btn_time_zoom_in = Button::default().with_label("+");
   759	    btn_time_zoom_in.set_color(theme::color(theme::BG_WIDGET));
   760	    btn_time_zoom_in.set_label_color(theme::color(theme::TEXT_PRIMARY));
   761	    btn_time_zoom_in.set_label_size(12);
   762	    set_tooltip(&mut btn_time_zoom_in, "Zoom in on time axis.");
   763	    time_zoom_row.fixed(&btn_time_zoom_in, 20);
   764	
   765	    time_zoom_row.end();
   766	    right.fixed(&time_zoom_row, 20);
   767	
   768	    // ── Transport bar ──
   769	    let mut transport_row = Flex::default().row();
   770	    transport_row.set_color(theme::color(theme::BG_PANEL));
   771	    right.fixed(&transport_row, 32);
   772	
   773	    let mut btn_play = Button::default().with_label("@>");
   774	    btn_play.set_color(theme::color(theme::BG_WIDGET));
   775	    btn_play.set_label_color(theme::color(theme::ACCENT_GREEN));
   776	    btn_play.deactivate();
   777	    set_tooltip(&mut btn_play, "Play audio from current position.");
   778	    transport_row.fixed(&btn_play, 36);
   779	
   780	    let mut btn_pause = Button::default().with_label("@||");
   781	    btn_pause.set_color(theme::color(theme::BG_WIDGET));
   782	    btn_pause.set_label_color(theme::color(theme::ACCENT_YELLOW));
   783	    btn_pause.deactivate();
   784	    set_tooltip(&mut btn_pause, "Pause playback at current position.");
   785	    transport_row.fixed(&btn_pause, 36);
   786	
   787	    let mut btn_stop = Button::default().with_label("@square");
   788	    btn_stop.set_color(theme::color(theme::BG_WIDGET));
   789	    btn_stop.set_label_color(theme::color(theme::ACCENT_RED));
   790	    btn_stop.deactivate();
   791	    set_tooltip(&mut btn_stop, "Stop playback and reset to start.");
   792	    transport_row.fixed(&btn_stop, 36);
   793	
   794	    // Scrub slider
   795	    let mut scrub_slider = HorSlider::default();
   796	    scrub_slider.set_minimum(0.0);
   797	    scrub_slider.set_maximum(1.0);
   798	    scrub_slider.set_value(0.0);
   799	    scrub_slider.set_color(theme::color(theme::BG_WIDGET));
   800	    scrub_slider.set_selection_color(theme::color(theme::ACCENT_RED));
   801	    scrub_slider.deactivate();
   802	    set_tooltip(&mut scrub_slider, "Playback position scrubber.\nDrag to seek. Audio plays from drag position when in play mode.");
   803	
   804	    let mut lbl_time = Frame::default().with_label("0:00.00 / 0:00.00");
   805	    lbl_time.set_label_color(theme::color(theme::TEXT_SECONDARY));
   806	    lbl_time.set_label_size(11);
   807	    transport_row.fixed(&lbl_time, 120);
   808	
   809	    let mut repeat_choice = Choice::default();
   810	    repeat_choice.add_choice("Single");
   811	    repeat_choice.add_choice("Repeat");
   812	    repeat_choice.set_value(0);
   813	    repeat_choice.set_color(theme::color(theme::BG_WIDGET));
   814	    repeat_choice.set_text_color(theme::color(theme::TEXT_PRIMARY));
   815	    repeat_choice.deactivate();
   816	    set_tooltip(&mut repeat_choice, "Single: stop at end.\nRepeat: loop continuously.");
   817	    transport_row.fixed(&repeat_choice, 70);
   818	
   819	    transport_row.end();
   820	
   821	    right.end();
   822	    root.end();
   823	
   824	    // ─── STATUS BAR ───────────────────────────────────────────────────────────
   825	
   826	    let mut status_bar = Frame::default()
   827	        .with_pos(0, WIN_H - STATUS_H)
   828	        .with_size(WIN_W, STATUS_H)
   829	        .with_label("Ready | Load an audio file to begin");
   830	    status_bar.set_frame(FrameType::FlatBox);
   831	    status_bar.set_color(theme::color(theme::BG_PANEL));
   832	    status_bar.set_label_color(theme::color(theme::TEXT_SECONDARY));
   833	    status_bar.set_label_size(11);
   834	    status_bar.set_align(Align::Inside | Align::Left);
   835	
   836	    win.end();
   837	
   838	    // Make the window resize properly
   839	    win.resizable(&root);
   840	
   841	    // ═══════════════════════════════════════════════════════════════════════════
   842	    //  MENU CALLBACKS
   843	    // ═══════════════════════════════════════════════════════════════════════════
   844	
   845	    {
   846	        let mut btn_open = btn_open.clone();
   847	        menu.add("&File/Open Audio\t", Shortcut::Ctrl | 'o', MenuFlag::Normal,
   848	            move |_| { btn_open.do_callback(); });
   849	    }
   850	    {
   851	        let mut btn_save_fft = btn_save_fft.clone();
   852	        menu.add("&File/Save FFT Data\t", Shortcut::Ctrl | 's', MenuFlag::Normal,
   853	            move |_| { btn_save_fft.do_callback(); });
   854	    }
   855	    {
   856	        let mut btn_load_fft = btn_load_fft.clone();
   857	        menu.add("&File/Load FFT Data\t", Shortcut::Ctrl | 'l', MenuFlag::Normal,
   858	            move |_| { btn_load_fft.do_callback(); });
   859	    }
   860	    {
   861	        let mut btn_save_wav = btn_save_wav.clone();
   862	        menu.add("&File/Export WAV\t", Shortcut::Ctrl | 'e', MenuFlag::Normal,
   863	            move |_| { btn_save_wav.do_callback(); });
   864	    }
   865	    menu.add("&File/Quit\t", Shortcut::Ctrl | 'q', MenuFlag::Normal,
   866	        move |_| { app::quit(); });
   867	
   868	    {
   869	        let mut btn_rerun = btn_rerun.clone();
   870	        menu.add("&Analysis/Recompute FFT\t", Shortcut::None, MenuFlag::Normal,
   871	            move |_| { btn_rerun.do_callback(); });
   872	    }
   873	
   874	    {
   875	        let state_c = state.clone();
   876	        let mut spec_display_c = spec_display.clone();
   877	        menu.add("&Display/Reset Zoom\t", Shortcut::None, MenuFlag::Normal,
   878	            move |_| {
   879	                let mut st = state_c.borrow_mut();
   880	                st.view.reset_zoom();
   881	                st.spec_renderer.invalidate();
   882	                st.wave_renderer.invalidate();
   883	                drop(st);
   884	                spec_display_c.redraw();
   885	            });
   886	    }
   887	
   888	    // ═══════════════════════════════════════════════════════════════════════════
   889	    //  HELPER: Update derived info labels
   890	    // ═══════════════════════════════════════════════════════════════════════════
   891	
   892	    // Type alias for shared mutable closures
   893	    type SharedCb = Rc<RefCell<Box<dyn FnMut()>>>;
   894	
   895	    let update_info: SharedCb = {
   896	        let state = state.clone();
   897	        let mut lbl_info = lbl_info.clone();
   898	        let mut input_freq_count = input_freq_count.clone();
   899	        Rc::new(RefCell::new(Box::new(move || {
   900	            let st = state.borrow();
   901	            let info = st.derived_info();
   902	            lbl_info.set_label(&info.format_info());
   903	
   904	            // Clamp freq count display to max
   905	            let current: usize = input_freq_count.value().parse().unwrap_or(info.freq_bins);
   906	            if current > info.freq_bins {
   907	                input_freq_count.set_value(&info.freq_bins.to_string());
   908	            }
   909	        })))
   910	    };
   911	
   912	    // Helper: update segment size label with dual display
   913	    let update_seg_label: SharedCb = {
   914	        let state = state.clone();
   915	        let mut lbl_seg_value = lbl_seg_value.clone();
   916	        Rc::new(RefCell::new(Box::new(move || {
   917	            let st = state.borrow();
   918	            let wl = st.fft_params.window_length;
   919	            let sr = st.fft_params.sample_rate;
   920	            let ms = wl as f64 / sr as f64 * 1000.0;
   921	            lbl_seg_value.set_label(&format!("{} smp / {:.2} ms", wl, ms));
   922	        })))
   923	    };
   924	
   925	    // Helper: enable widgets that require audio data
   926	    let enable_audio_widgets: SharedCb = {
   927	        let mut btn_time_unit = btn_time_unit.clone();
   928	        let mut input_start = input_start.clone();
   929	        let mut input_stop = input_stop.clone();
   930	        let mut btn_seg_minus = btn_seg_minus.clone();
   931	        let mut btn_seg_plus = btn_seg_plus.clone();
   932	        let mut slider_overlap = slider_overlap.clone();
   933	        let mut window_type_choice = window_type_choice.clone();
   934	        let mut check_center = check_center.clone();
   935	        let mut btn_rerun = btn_rerun.clone();
   936	        Rc::new(RefCell::new(Box::new(move || {
   937	            btn_time_unit.activate();
   938	            input_start.activate();
   939	            input_stop.activate();
   940	            btn_seg_minus.activate();
   941	            btn_seg_plus.activate();
   942	            slider_overlap.activate();
   943	            window_type_choice.activate();
   944	            check_center.activate();
   945	            btn_rerun.activate();
   946	        })))
   947	    };
   948	
   949	    // Helper: enable widgets that require spectrogram data
   950	    let enable_spec_widgets: SharedCb = {
   951	        let mut btn_save_fft = btn_save_fft.clone();
   952	        let mut input_freq_count = input_freq_count.clone();
   953	        let mut input_recon_freq_min = input_recon_freq_min.clone();
   954	        let mut input_recon_freq_max = input_recon_freq_max.clone();
   955	        let mut btn_play = btn_play.clone();
   956	        let mut btn_pause = btn_pause.clone();
   957	        let mut btn_stop = btn_stop.clone();
   958	        let mut scrub_slider = scrub_slider.clone();
   959	        let mut repeat_choice = repeat_choice.clone();
   960	        let mut btn_snap_to_view = btn_snap_to_view.clone();
   961	        Rc::new(RefCell::new(Box::new(move || {
   962	            btn_save_fft.activate();
   963	            input_freq_count.activate();
   964	            input_recon_freq_min.activate();
   965	            input_recon_freq_max.activate();
   966	            btn_play.activate();
   967	            btn_pause.activate();
   968	            btn_stop.activate();
   969	            scrub_slider.activate();
   970	            repeat_choice.activate();
   971	            btn_snap_to_view.activate();
   972	        })))
   973	    };
   974	
   975	    // Helper: enable WAV export when reconstruction is ready
   976	    let enable_wav_export: SharedCb = {
   977	        let mut btn_save_wav = btn_save_wav.clone();
   978	        Rc::new(RefCell::new(Box::new(move || {
   979	            btn_save_wav.activate();
   980	        })))
   981	    };
   982	
   983	    // ═══════════════════════════════════════════════════════════════════════════
   984	    //  CALLBACKS
   985	    // ═══════════════════════════════════════════════════════════════════════════
   986	
   987	    // ── Open Audio File ──
   988	    {
   989	        let state = state.clone();
   990	        let mut status_bar = status_bar.clone();
   991	        let mut input_stop = input_stop.clone();
   992	        let mut input_recon_freq_max = input_recon_freq_max.clone();
   993	        let mut spec_display = spec_display.clone();
   994	        let mut waveform_display = waveform_display.clone();
   995	        let tx = tx.clone();
   996	        let update_info = update_info.clone();
   997	        let update_seg_label = update_seg_label.clone();
   998	        let enable_audio_widgets = enable_audio_widgets.clone();
   999	
  1000	        btn_open.set_callback(move |_| {
  1001	            let mut chooser = dialog::NativeFileChooser::new(dialog::NativeFileChooserType::BrowseFile);
  1002	            chooser.set_filter("*.wav");
  1003	            chooser.show();
  1004	
  1005	            let filename = chooser.filename();
  1006	            if filename.as_os_str().is_empty() {
  1007	                return;
  1008	            }
  1009	
  1010	            status_bar.set_label("Loading audio...");
  1011	            app::awake();
  1012	
  1013	            match AudioData::from_wav_file(&filename) {
  1014	                Ok(audio) => {
  1015	                    let duration = audio.duration_seconds;
  1016	                    let nyquist = audio.nyquist_freq();
  1017	                    let sample_rate = audio.sample_rate;
  1018	                    let audio = Arc::new(audio);
  1019	
  1020	                    let params_clone;
  1021	                    {
  1022	                        let mut st = state.borrow_mut();
  1023	                        st.fft_params.sample_rate = sample_rate;
  1024	                        st.fft_params.stop_time = duration;
  1025	                        st.audio_data = Some(audio.clone());
  1026	                        st.has_audio = true;
  1027	
  1028	                        // Set view bounds
  1029	                        st.view.data_time_min_sec = 0.0;
  1030	                        st.view.data_time_max_sec = duration;
  1031	                        st.view.time_min_sec = 0.0;
  1032	                        st.view.time_max_sec = duration;
  1033	                        st.view.data_freq_max_hz = nyquist;
  1034	                        st.view.freq_max_hz = nyquist;
  1035	                        st.view.recon_freq_max_hz = nyquist;
  1036	                        st.view.max_freq_bins = st.fft_params.num_frequency_bins();
  1037	                        st.view.recon_freq_count = st.fft_params.num_frequency_bins();
  1038	
  1039	                        st.transport.duration_seconds = duration;
  1040	                        st.transport.position_seconds = 0.0;
  1041	
  1042	                        st.spec_renderer.invalidate();
  1043	                        st.wave_renderer.invalidate();
  1044	
  1045	                        params_clone = st.fft_params.clone();
  1046	                        st.is_processing = true;
  1047	                    }
  1048	
  1049	                    input_stop.set_value(&format!("{:.5}", duration));
  1050	                    input_recon_freq_max.set_value(&format!("{:.0}", nyquist));
  1051	
  1052	                    (enable_audio_widgets.borrow_mut())();
  1053	                    (update_info.borrow_mut())();
  1054	                    (update_seg_label.borrow_mut())();
  1055	
  1056	                    // Launch background FFT (reconstruction auto-follows via FftComplete handler)
  1057	                    let tx_clone = tx.clone();
  1058	                    let audio_for_fft = audio.clone();
  1059	                    std::thread::spawn(move || {
  1060	                        let spectrogram = FftEngine::process(&audio_for_fft, &params_clone);
  1061	                        tx_clone.send(WorkerMessage::FftComplete(spectrogram)).ok();
  1062	                    });
  1063	
  1064	                    status_bar.set_label(&format!(
  1065	                        "Processing FFT... | {:.2}s | {} Hz | {}",
  1066	                        duration, sample_rate,
  1067	                        filename.file_name().unwrap_or_default().to_string_lossy()
  1068	                    ));
  1069	                    spec_display.redraw();
  1070	                    waveform_display.redraw();
  1071	                }
  1072	                Err(e) => {
  1073	                    dialog::alert_default(&format!("Error loading audio:\n{}", e));
  1074	                    status_bar.set_label("Load failed");
  1075	                }
  1076	            }
  1077	        });
  1078	    }
  1079	
  1080	    // ── Save FFT to CSV ──
  1081	    {
  1082	        let state = state.clone();
  1083	        let mut status_bar = status_bar.clone();
  1084	
  1085	        btn_save_fft.set_callback(move |_| {
  1086	            let st = state.borrow();
  1087	            if st.spectrogram.is_none() {
  1088	                dialog::alert_default("No FFT data to save!");
  1089	                return;
  1090	            }
  1091	
  1092	            let mut chooser = dialog::NativeFileChooser::new(dialog::NativeFileChooserType::BrowseSaveFile);
  1093	            chooser.set_filter("*.csv");
  1094	            chooser.set_preset_file("fft_data.csv");
  1095	            chooser.show();
  1096	
  1097	            let filename = chooser.filename();
  1098	            if filename.as_os_str().is_empty() {
  1099	                return;
  1100	            }
  1101	
  1102	            // Filter spectrogram frames to processing time range (sidebar Start/Stop)
  1103	            // so the CSV only contains the section the user cares about.
  1104	            let spec_full = st.spectrogram.as_ref().unwrap();
  1105	            let proc_time_min = match st.fft_params.time_unit {
  1106	                TimeUnit::Seconds => st.fft_params.start_time,
  1107	                TimeUnit::Samples => st.fft_params.start_time / st.fft_params.sample_rate.max(1) as f64,
  1108	            };
  1109	            let proc_time_max = match st.fft_params.time_unit {
  1110	                TimeUnit::Seconds => st.fft_params.stop_time,
  1111	                TimeUnit::Samples => st.fft_params.stop_time / st.fft_params.sample_rate.max(1) as f64,
  1112	            };
  1113	            let filtered_frames: Vec<_> = spec_full.frames.iter()
  1114	                .filter(|f| f.time_seconds >= proc_time_min && f.time_seconds <= proc_time_max)
  1115	                .cloned()
  1116	                .collect();
  1117	            let filtered_spec = data::Spectrogram::from_frames(filtered_frames);
  1118	
  1119	            match csv_export::export_to_csv(&filtered_spec, &st.fft_params, &st.view, &filename) {
  1120	                Ok(_) => {
  1121	                    status_bar.set_label(&format!(
  1122	                        "FFT saved ({} frames, {:.2}s-{:.2}s)",
  1123	                        filtered_spec.num_frames(), proc_time_min, proc_time_max
  1124	                    ));
  1125	                }
  1126	                Err(e) => {
  1127	                    dialog::alert_default(&format!("Error saving CSV:\n{}", e));
  1128	                    status_bar.set_label("Save failed");
  1129	                }
  1130	            }
  1131	        });
  1132	    }
  1133	
  1134	    // ── Load FFT from CSV ──
  1135	    {
  1136	        let state = state.clone();
  1137	        let tx = tx.clone();
  1138	        let mut status_bar = status_bar.clone();
  1139	        let mut spec_display = spec_display.clone();
  1140	        let mut input_start = input_start.clone();
  1141	        let mut input_stop = input_stop.clone();
  1142	        let mut slider_overlap = slider_overlap.clone();
  1143	        let update_info = update_info.clone();
  1144	        let update_seg_label = update_seg_label.clone();
  1145	        let enable_audio_widgets = enable_audio_widgets.clone();
  1146	        let enable_spec_widgets = enable_spec_widgets.clone();
  1147	
  1148	        btn_load_fft.set_callback(move |_| {
  1149	            let mut chooser = dialog::NativeFileChooser::new(dialog::NativeFileChooserType::BrowseFile);
  1150	            chooser.set_filter("*.csv");
  1151	            chooser.show();
  1152	
  1153	            let filename = chooser.filename();
  1154	            if filename.as_os_str().is_empty() {
  1155	                return;
  1156	            }
  1157	
  1158	            status_bar.set_label("Loading CSV...");
  1159	            app::awake();
  1160	
  1161	            match csv_export::import_from_csv(&filename) {
  1162	                Ok((imported_spec, mut imported_params, recon_params)) => {
  1163	                    let num_frames = imported_spec.num_frames();
  1164	
  1165	                    // Ensure proc_time covers the full spectrogram range
  1166	                    // (avoids graying issues from integer sample roundtrip precision)
  1167	                    let spec_min_time = imported_spec.min_time;
  1168	                    let spec_max_time = imported_spec.max_time;
  1169	                    imported_params.start_time = spec_min_time;
  1170	                    imported_params.stop_time = spec_max_time;
  1171	                    imported_params.time_unit = TimeUnit::Seconds;
  1172	
  1173	                    let recon_data = {
  1174	                        let mut st = state.borrow_mut();
  1175	                        st.fft_params = imported_params.clone();
  1176	
  1177	                        st.view.time_min_sec = spec_min_time;
  1178	                        st.view.time_max_sec = spec_max_time;
  1179	                        st.view.data_time_min_sec = spec_min_time;
  1180	                        st.view.data_time_max_sec = spec_max_time;
  1181	                        st.view.freq_max_hz = imported_spec.max_freq;
  1182	                        st.view.data_freq_max_hz = imported_spec.max_freq;
  1183	
  1184	                        // Restore reconstruction params if present
  1185	                        if let Some((fc, fmin, fmax)) = recon_params {
  1186	                            st.view.recon_freq_count = fc;
  1187	                            st.view.recon_freq_min_hz = fmin;
  1188	                            st.view.recon_freq_max_hz = fmax;
  1189	                        }
  1190	
  1191	                        st.spectrogram = Some(Arc::new(imported_spec));
  1192	                        st.spec_renderer.invalidate();
  1193	                        st.wave_renderer.invalidate();
  1194	                        st.recon_start_time = spec_min_time;
  1195	                        st.is_processing = true;
  1196	                        st.dirty = false;
  1197	
  1198	                        // Prepare reconstruction data
  1199	                        let spec = st.spectrogram.clone().unwrap();
  1200	                        let params = st.fft_params.clone();
  1201	                        let view = st.view.clone();
  1202	                        (spec, params, view, spec_min_time, spec_max_time)
  1203	                    };
  1204	
  1205	                    input_start.set_value(&format!("{:.5}", imported_params.start_time));
  1206	                    input_stop.set_value(&format!("{:.5}", imported_params.stop_time));
  1207	                    slider_overlap.set_value(imported_params.overlap_percent as f64);
  1208	
  1209	                    (enable_audio_widgets.borrow_mut())();
  1210	                    (enable_spec_widgets.borrow_mut())();
  1211	                    (update_info.borrow_mut())();
  1212	                    (update_seg_label.borrow_mut())();
  1213	
  1214	                    status_bar.set_label(&format!(
  1215	                        "Loaded {} frames from CSV | Reconstructing...",
  1216	                        num_frames
  1217	                    ));
  1218	                    spec_display.redraw();
  1219	
  1220	                    // Auto-trigger reconstruction so sound can play
  1221	                    let tx_clone = tx.clone();
  1222	                    let (spec, params, view, proc_time_min, proc_time_max) = recon_data;
  1223	                    std::thread::spawn(move || {
  1224	                        let filtered_frames: Vec<_> = spec.frames.iter()
  1225	                            .filter(|f| f.time_seconds >= proc_time_min && f.time_seconds <= proc_time_max)
  1226	                            .cloned()
  1227	                            .collect();
  1228	                        let filtered_spec = data::Spectrogram::from_frames(filtered_frames);
  1229	                        let reconstructed = Reconstructor::reconstruct(&filtered_spec, &params, &view);
  1230	                        tx_clone.send(WorkerMessage::ReconstructionComplete(reconstructed)).ok();
  1231	                    });
  1232	                }
  1233	                Err(e) => {
  1234	                    dialog::alert_default(&format!("Error loading CSV:\n{}", e));
  1235	                    status_bar.set_label("CSV load failed");
  1236	                }
  1237	            }
  1238	        });
  1239	    }
  1240	
  1241	    // ── Export WAV ──
  1242	    {
  1243	        let state = state.clone();
  1244	        let mut status_bar = status_bar.clone();
  1245	
  1246	        btn_save_wav.set_callback(move |_| {
  1247	            let st = state.borrow();
  1248	            if st.reconstructed_audio.is_none() {
  1249	                dialog::alert_default("No reconstructed audio to save!\n\nReconstruct audio first.");
  1250	                return;
  1251	            }
  1252	
  1253	            let mut chooser = dialog::NativeFileChooser::new(dialog::NativeFileChooserType::BrowseSaveFile);
  1254	            chooser.set_filter("*.wav");
  1255	            chooser.set_preset_file("reconstructed.wav");
  1256	            chooser.show();
  1257	
  1258	            let filename = chooser.filename();
  1259	            if filename.as_os_str().is_empty() {
  1260	                return;
  1261	            }
  1262	
  1263	            match st.reconstructed_audio.as_ref().unwrap().save_wav(&filename) {
  1264	                Ok(_) => {
  1265	                    status_bar.set_label(&format!("WAV saved: {:?}", filename));
  1266	                }
  1267	                Err(e) => {
  1268	                    dialog::alert_default(&format!("Error saving WAV:\n{}", e));
  1269	                    status_bar.set_label("WAV save failed");
  1270	                }
  1271	            }
  1272	        });
  1273	    }
  1274	
  1275	    // ── Rerun analysis + reconstruction (also triggered by spacebar) ──
  1276	    // Reads ALL current field values before launching FFT so that
  1277	    // typing a number + spacebar works without needing to press Enter.
  1278	    // After FFT completes, reconstruction is automatically triggered.
  1279	    {
  1280	        let state = state.clone();
  1281	        let mut status_bar = status_bar.clone();
  1282	        let mut spec_display = spec_display.clone();
  1283	        let mut waveform_display = waveform_display.clone();
  1284	        let tx = tx.clone();
  1285	        let input_start = input_start.clone();
  1286	        let input_stop = input_stop.clone();
  1287	        let slider_overlap = slider_overlap.clone();
  1288	        let input_freq_count = input_freq_count.clone();
  1289	        let input_recon_freq_min = input_recon_freq_min.clone();
  1290	        let input_recon_freq_max = input_recon_freq_max.clone();
  1291	        let check_center = check_center.clone();
  1292	        let update_info = update_info.clone();
  1293	        let update_seg_label = update_seg_label.clone();
  1294	        let window_type_choice = window_type_choice.clone();
  1295	        let input_kaiser_beta = input_kaiser_beta.clone();
  1296	
  1297	        btn_rerun.set_callback(move |_| {
  1298	            // Sync all field values into state before running
  1299	            {
  1300	                let mut st = state.borrow_mut();
  1301	                if st.audio_data.is_none() { return; }
  1302	                if st.is_processing { return; }
  1303	
  1304	                // Read current field values for processing time range
  1305	                st.fft_params.start_time = parse_or_zero_f64(&input_start.value());
  1306	                st.fft_params.stop_time = parse_or_zero_f64(&input_stop.value());
  1307	
  1308	                // Window length is managed by +/- buttons, already in state
  1309	                st.fft_params.overlap_percent = slider_overlap.value() as f32;
  1310	                st.fft_params.use_center = check_center.is_checked();
  1311	
  1312	                // Read window type + kaiser beta
  1313	                st.fft_params.window_type = match window_type_choice.value() {
  1314	                    0 => WindowType::Hann,
  1315	                    1 => WindowType::Hamming,
  1316	                    2 => WindowType::Blackman,
  1317	                    3 => {
  1318	                        let beta = parse_or_zero_f32(&input_kaiser_beta.value());
  1319	                        WindowType::Kaiser(if beta > 0.0 { beta } else { 8.6 })
  1320	                    }
  1321	                    _ => WindowType::Hann,
  1322	                };
  1323	
  1324	                // Update reconstruction params
  1325	                let fc = parse_or_zero_usize(&input_freq_count.value()).max(1);
  1326	                st.view.recon_freq_count = fc;
  1327	                st.view.recon_freq_min_hz = parse_or_zero_f32(&input_recon_freq_min.value());
  1328	                st.view.recon_freq_max_hz = parse_or_zero_f32(&input_recon_freq_max.value());
  1329	                st.view.max_freq_bins = st.fft_params.num_frequency_bins();
  1330	
  1331	                st.is_processing = true;
  1332	                st.dirty = false;
  1333	                st.spec_renderer.invalidate();
  1334	                st.wave_renderer.invalidate();
  1335	            }
  1336	
  1337	            // FFT processes the FULL file; sidebar time range is for reconstruction only
  1338	            let (audio, params) = {
  1339	                let st = state.borrow();
  1340	                let mut fft_params = st.fft_params.clone();
  1341	                // Override start/stop to process full file
  1342	                fft_params.start_time = 0.0;
  1343	                fft_params.stop_time = st.audio_data.as_ref().unwrap().duration_seconds;
  1344	                fft_params.time_unit = TimeUnit::Seconds;
  1345	                (st.audio_data.clone().unwrap(), fft_params)
  1346	            };
  1347	
  1348	            (update_info.borrow_mut())();
  1349	            (update_seg_label.borrow_mut())();
  1350	            status_bar.set_label("Processing FFT + Reconstruct...");
  1351	            app::awake();
  1352	
  1353	            let tx_clone = tx.clone();
  1354	            std::thread::spawn(move || {
  1355	                let spectrogram = FftEngine::process(&audio, &params);
  1356	                tx_clone.send(WorkerMessage::FftComplete(spectrogram)).ok();
  1357	            });
  1358	
  1359	            spec_display.redraw();
  1360	            waveform_display.redraw();
  1361	        });
  1362	    }
  1363	
  1364	    // ── Parameter callbacks ──
  1365	
  1366	    // Time unit toggle
  1367	    {
  1368	        let state = state.clone();
  1369	        let mut input_start = input_start.clone();
  1370	        let mut input_stop = input_stop.clone();
  1371	
  1372	        btn_time_unit.set_callback(move |btn| {
  1373	            let mut st = state.borrow_mut();
  1374	            let sr = st.fft_params.sample_rate as f64;
  1375	            match st.fft_params.time_unit {
  1376	                TimeUnit::Seconds => {
  1377	                    // Convert seconds -> samples
  1378	                    let start_samples = (st.fft_params.start_time * sr) as u64;
  1379	                    let stop_samples = (st.fft_params.stop_time * sr) as u64;
  1380	                    st.fft_params.time_unit = TimeUnit::Samples;
  1381	                    st.fft_params.start_time = start_samples as f64;
  1382	                    st.fft_params.stop_time = stop_samples as f64;
  1383	                    input_start.set_value(&start_samples.to_string());
  1384	                    input_stop.set_value(&stop_samples.to_string());
  1385	                    btn.set_label("Unit: Samples");
  1386	                }
  1387	                TimeUnit::Samples => {
  1388	                    // Convert samples -> seconds
  1389	                    let start_secs = st.fft_params.start_time / sr;
  1390	                    let stop_secs = st.fft_params.stop_time / sr;
  1391	                    st.fft_params.time_unit = TimeUnit::Seconds;
  1392	                    st.fft_params.start_time = start_secs;
  1393	                    st.fft_params.stop_time = stop_secs;
  1394	                    input_start.set_value(&format!("{:.5}", start_secs));
  1395	                    input_stop.set_value(&format!("{:.5}", stop_secs));
  1396	                    btn.set_label("Unit: Seconds");
  1397	                }
  1398	            }
  1399	        });
  1400	    }
  1401	
  1402	    // Field values are read at recompute time (btn_rerun callback).
  1403	    // No individual callbacks needed for start/stop/window_len.
  1404	
  1405	    // Overlap
  1406	    {
  1407	        let mut lbl = lbl_overlap_val.clone();
  1408	        let state = state.clone();
  1409	        let update_info = update_info.clone();
  1410	
  1411	        slider_overlap.set_callback(move |s| {
  1412	            let val = s.value() as f32;
  1413	            lbl.set_label(&format!("Overlap: {}%", val as i32));
  1414	            state.borrow_mut().fft_params.overlap_percent = val;
  1415	            (update_info.borrow_mut())();
  1416	        });
  1417	    }
  1418	
  1419	    // Window type (kaiser beta is read at recompute time from the field)
  1420	    {
  1421	        let state = state.clone();
  1422	        let mut input_kaiser_beta = input_kaiser_beta.clone();
  1423	
  1424	        window_type_choice.set_callback(move |c| {
  1425	            let mut st = state.borrow_mut();
  1426	            st.fft_params.window_type = match c.value() {
  1427	                0 => { input_kaiser_beta.deactivate(); WindowType::Hann }
  1428	                1 => { input_kaiser_beta.deactivate(); WindowType::Hamming }
  1429	                2 => { input_kaiser_beta.deactivate(); WindowType::Blackman }
  1430	                3 => {
  1431	                    input_kaiser_beta.activate();
  1432	                    let beta = parse_or_zero_f32(&input_kaiser_beta.value());
  1433	                    WindowType::Kaiser(if beta > 0.0 { beta } else { 8.6 })
  1434	                }
  1435	                _ => WindowType::Hann,
  1436	            };
  1437	        });
  1438	    }
  1439	
  1440	    // Segment size +/- buttons
  1441	    {
  1442	        let state = state.clone();
  1443	        let update_info = update_info.clone();
  1444	        let update_seg_label = update_seg_label.clone();
  1445	
  1446	        btn_seg_minus.set_callback(move |_| {
  1447	            let mut st = state.borrow_mut();
  1448	            let new_wl = (st.fft_params.window_length / 2).max(64);
  1449	            st.fft_params.window_length = new_wl;
  1450	            drop(st);
  1451	            (update_info.borrow_mut())();
  1452	            (update_seg_label.borrow_mut())();
  1453	        });
  1454	    }
  1455	    {
  1456	        let state = state.clone();
  1457	        let update_info = update_info.clone();
  1458	        let update_seg_label = update_seg_label.clone();
  1459	
  1460	        btn_seg_plus.set_callback(move |_| {
  1461	            let mut st = state.borrow_mut();
  1462	            let new_wl = (st.fft_params.window_length * 2).min(65536);
  1463	            st.fft_params.window_length = new_wl;
  1464	            drop(st);
  1465	            (update_info.borrow_mut())();
  1466	            (update_seg_label.borrow_mut())();
  1467	        });
  1468	    }
  1469	
  1470	    // Kaiser beta - read at recompute time, but also sync when window type changes
  1471	    attach_float_validation(&mut input_kaiser_beta);
  1472	
  1473	    // Center/Pad
  1474	    {
  1475	        let state = state.clone();
  1476	        let update_info = update_info.clone();
  1477	        check_center.set_callback(move |c| {
  1478	            state.borrow_mut().fft_params.use_center = c.is_checked();
  1479	            (update_info.borrow_mut())();
  1480	        });
  1481	    }
  1482	
  1483	    // ── Display callbacks ──
  1484	
  1485	    // Colormap
  1486	    {
  1487	        let state = state.clone();
  1488	        let mut spec_display = spec_display.clone();
  1489	
  1490	        colormap_choice.set_callback(move |c| {
  1491	            let mut st = state.borrow_mut();
  1492	            st.view.colormap = ColormapId::from_index(c.value() as usize);
  1493	            st.spec_renderer.invalidate();
  1494	            drop(st);
  1495	            spec_display.redraw();
  1496	        });
  1497	    }
  1498	
  1499	    // Scale
  1500	    {
  1501	        let state = state.clone();
  1502	        let mut spec_display = spec_display.clone();
  1503	
  1504	        scale_choice.set_callback(move |c| {
  1505	            let mut st = state.borrow_mut();
  1506	            st.view.freq_scale = if c.value() == 0 { FreqScale::Log } else { FreqScale::Linear };
  1507	            st.spec_renderer.invalidate();
  1508	            drop(st);
  1509	            spec_display.redraw();
  1510	        });
  1511	    }
  1512	
  1513	    // Threshold
  1514	    {
  1515	        let mut lbl = lbl_threshold_val.clone();
  1516	        let state = state.clone();
  1517	        let mut spec_display = spec_display.clone();
  1518	        let throttle = Rc::new(RefCell::new(UpdateThrottle::new(50)));
  1519	
  1520	        slider_threshold.set_callback(move |s| {
  1521	            let val = s.value() as f32;
  1522	            lbl.set_label(&format!("Threshold: {} dB", val as i32));
  1523	            state.borrow_mut().view.threshold_db = val;
  1524	
  1525	            if throttle.borrow_mut().should_update() {
  1526	                state.borrow_mut().spec_renderer.invalidate();
  1527	                spec_display.redraw();
  1528	            }
  1529	        });
  1530	    }
  1531	
  1532	    // Brightness
  1533	    {
  1534	        let mut lbl = lbl_brightness_val.clone();
  1535	        let state = state.clone();
  1536	        let mut spec_display = spec_display.clone();
  1537	        let throttle = Rc::new(RefCell::new(UpdateThrottle::new(50)));
  1538	
  1539	        slider_brightness.set_callback(move |s| {
  1540	            let val = s.value() as f32;
  1541	            lbl.set_label(&format!("Brightness: {:.1}", val));
  1542	            state.borrow_mut().view.brightness = val;
  1543	
  1544	            if throttle.borrow_mut().should_update() {
  1545	                state.borrow_mut().spec_renderer.invalidate();
  1546	                spec_display.redraw();
  1547	            }
  1548	        });
  1549	    }
  1550	
  1551	    // Gamma
  1552	    {
  1553	        let mut lbl = lbl_gamma_val.clone();
  1554	        let state = state.clone();
  1555	        let mut spec_display = spec_display.clone();
  1556	        let throttle = Rc::new(RefCell::new(UpdateThrottle::new(50)));
  1557	
  1558	        slider_gamma.set_callback(move |s| {
  1559	            let val = s.value() as f32;
  1560	            lbl.set_label(&format!("Gamma: {:.1}", val));
  1561	            state.borrow_mut().view.gamma = val;
  1562	
  1563	            if throttle.borrow_mut().should_update() {
  1564	                state.borrow_mut().spec_renderer.invalidate();
  1565	                spec_display.redraw();
  1566	            }
  1567	        });
  1568	    }
  1569	
  1570	    // Reconstruction is now triggered automatically after FFT completes.
  1571	    // No separate callback needed.
  1572	
  1573	    // ── Playback callbacks ──
  1574	
  1575	    {
  1576	        let state = state.clone();
  1577	        let mut btn_rerun = btn_rerun.clone();
  1578	        btn_play.set_callback(move |_| {
  1579	            let mut st = state.borrow_mut();
  1580	            if st.dirty {
  1581	                // Need to recompute first - trigger rerun, then play will happen after
  1582	                drop(st);
  1583	                btn_rerun.do_callback();
  1584	                // Play will need to be pressed again after recompute
  1585	                return;
  1586	            }
  1587	            st.audio_player.play();
  1588	            st.transport.is_playing = true;
  1589	        });
  1590	    }
  1591	    {
  1592	        let state = state.clone();
  1593	        btn_pause.set_callback(move |_| {
  1594	            let mut st = state.borrow_mut();
  1595	            st.audio_player.pause();
  1596	            st.transport.is_playing = false;
  1597	        });
  1598	    }
  1599	    {
  1600	        let state = state.clone();
  1601	        btn_stop.set_callback(move |_| {
  1602	            let mut st = state.borrow_mut();
  1603	            st.audio_player.stop();
  1604	            st.transport.is_playing = false;
  1605	            st.transport.position_seconds = 0.0;
  1606	        });
  1607	    }
  1608	
  1609	    // Scrub slider - seeks within the reconstructed audio
  1610	    {
  1611	        let state = state.clone();
  1612	
  1613	        scrub_slider.set_callback(move |s| {
  1614	            let st = state.borrow();
  1615	            let audio_position = s.value() * st.transport.duration_seconds;
  1616	            st.audio_player.seek_to(audio_position);
  1617	        });
  1618	    }
  1619	
  1620	    // Repeat
  1621	    {
  1622	        let state = state.clone();
  1623	        repeat_choice.set_callback(move |c| {
  1624	            let mut st = state.borrow_mut();
  1625	            st.audio_player.set_repeat(c.value() == 1);
  1626	            st.transport.repeat = c.value() == 1;
  1627	        });
  1628	    }
  1629	
  1630	    // Tooltip toggle
  1631	    {
  1632	        let state = state.clone();
  1633	        btn_tooltips.set_callback(move |c| {
  1634	            state.borrow_mut().tooltip_mgr.set_enabled(c.is_checked());
  1635	        });
  1636	    }
  1637	
  1638	    // Lock to Active toggle
  1639	    {
  1640	        let state = state.clone();
  1641	        check_lock_active.set_callback(move |c| {
  1642	            state.borrow_mut().lock_to_active = c.is_checked();
  1643	        });
  1644	    }
  1645	
  1646	    // Home button — snap viewport to processing time range
  1647	    {
  1648	        let state = state.clone();
  1649	        let mut spec_display = spec_display.clone();
  1650	        let mut waveform_display = waveform_display.clone();
  1651	
  1652	        btn_home.set_callback(move |_| {
  1653	            let mut st = state.borrow_mut();
  1654	            let proc_min = match st.fft_params.time_unit {
  1655	                TimeUnit::Seconds => st.fft_params.start_time,
  1656	                TimeUnit::Samples => st.fft_params.start_time / st.fft_params.sample_rate.max(1) as f64,
  1657	            };
  1658	            let proc_max = match st.fft_params.time_unit {
  1659	                TimeUnit::Seconds => st.fft_params.stop_time,
  1660	                TimeUnit::Samples => st.fft_params.stop_time / st.fft_params.sample_rate.max(1) as f64,
  1661	            };
  1662	            if proc_max > proc_min {
  1663	                st.view.time_min_sec = proc_min.max(st.view.data_time_min_sec);
  1664	                st.view.time_max_sec = proc_max.min(st.view.data_time_max_sec);
  1665	                st.spec_renderer.invalidate();
  1666	                st.wave_renderer.invalidate();
  1667	            }
  1668	            drop(st);
  1669	            spec_display.redraw();
  1670	            waveform_display.redraw();
  1671	        });
  1672	    }
  1673	
  1674	    // ═══════════════════════════════════════════════════════════════════════════
  1675	    //  DRAW CALLBACKS
  1676	    // ═══════════════════════════════════════════════════════════════════════════
  1677	
  1678	    // ── Spectrogram display ──
  1679	    {
  1680	        let state = state.clone();
  1681	
  1682	        spec_display.draw(move |w| {
  1683	            if !w.visible_r() || w.w() <= 0 || w.h() <= 0 {
  1684	                return;
  1685	            }
  1686	
  1687	            let Ok(mut st) = state.try_borrow_mut() else { return; };
  1688	
  1689	            if let Some(spec) = st.spectrogram.clone() {
  1690	                let view = st.view.clone();
  1691	                // Get processing time range from fft_params (sidebar Start/Stop)
  1692	                let proc_time_min = match st.fft_params.time_unit {
  1693	                    TimeUnit::Seconds => st.fft_params.start_time,
  1694	                    TimeUnit::Samples => st.fft_params.start_time / st.fft_params.sample_rate.max(1) as f64,
  1695	                };
  1696	                let proc_time_max = match st.fft_params.time_unit {
  1697	                    TimeUnit::Seconds => st.fft_params.stop_time,
  1698	                    TimeUnit::Samples => st.fft_params.stop_time / st.fft_params.sample_rate.max(1) as f64,
  1699	                };
  1700	                st.spec_renderer.draw(&spec, &view, proc_time_min, proc_time_max, w.x(), w.y(), w.w(), w.h());
  1701	
  1702	                // Draw playback cursor (playback position is relative to recon_start_time)
  1703	                if st.transport.duration_seconds > 0.0 {
  1704	                    let playback_time = st.recon_start_time + st.audio_player.get_position_seconds();
  1705	                    let cursor_t = st.view.time_to_x(playback_time);
  1706	                    if cursor_t >= 0.0 && cursor_t <= 1.0 {
  1707	                        let cx = w.x() + (cursor_t * w.w() as f64) as i32;
  1708	                        fltk::draw::set_draw_color(theme::color(theme::ACCENT_RED));
  1709	                        fltk::draw::draw_line(cx, w.y(), cx, w.y() + w.h());
  1710	                    }
  1711	                }
  1712	            } else {
  1713	                fltk::draw::set_draw_color(theme::color(theme::BG_DARK));
  1714	                fltk::draw::draw_rectf(w.x(), w.y(), w.w(), w.h());
  1715	                fltk::draw::set_draw_color(theme::color(theme::TEXT_DISABLED));
  1716	                fltk::draw::set_font(Font::Helvetica, 14);
  1717	                fltk::draw::draw_text("Load an audio file to begin", w.x() + 10, w.y() + w.h() / 2);
  1718	            }
  1719	        });
  1720	    }
  1721	
  1722	    // ── Spectrogram mouse handling (seek + hover readout + zoom) ──
  1723	    {
  1724	        let state = state.clone();
  1725	        let mut status_bar = status_bar.clone();
  1726	        let mut spec_display_c = spec_display.clone();
  1727	        let mut waveform_display_c = waveform_display.clone();
  1728	
  1729	        spec_display.handle(move |w, ev| {
  1730	            match ev {
  1731	                Event::Push => {
  1732	                    // Click to seek - convert spectrogram time to audio position
  1733	                    let mx = app::event_x() - w.x();
  1734	                    let t = mx as f64 / w.w() as f64;
  1735	                    let st = state.borrow();
  1736	                    let time = st.view.x_to_time(t);
  1737	                    // Seek is relative to recon_start_time
  1738	                    let audio_pos = (time - st.recon_start_time).max(0.0);
  1739	                    st.audio_player.seek_to(audio_pos);
  1740	                    true
  1741	                }
  1742	                Event::Move => {
  1743	                    // Hover readout
  1744	                    let mx = app::event_x() - w.x();
  1745	                    let my = app::event_y() - w.y();
  1746	                    let tx_norm = mx as f64 / w.w() as f64;
  1747	                    let ty_norm = 1.0 - (my as f32 / w.h() as f32);  // flip Y
  1748	
  1749	                    let st = state.borrow();
  1750	                    let time = st.view.x_to_time(tx_norm);
  1751	                    let freq = st.view.y_to_freq(ty_norm);
  1752	
  1753	                    if let Some(ref spec) = st.spectrogram {
  1754	                        if let Some(frame_idx) = spec.frame_at_time(time) {
  1755	                            if let Some(bin_idx) = spec.bin_at_freq(freq) {
  1756	                                if let Some(mag) = spec.frames.get(frame_idx)
  1757	                                    .and_then(|f| f.magnitudes.get(bin_idx))
  1758	                                {
  1759	                                    let db = data::Spectrogram::magnitude_to_db(*mag);
  1760	                                    status_bar.set_label(&format!(
  1761	                                        "Cursor: {:.1} Hz | {:.1} dB | {:.3}s",
  1762	                                        freq, db, time
  1763	                                    ));
  1764	                                }
  1765	                            }
  1766	                        }
  1767	                    }
  1768	                    true
  1769	                }
  1770	                Event::MouseWheel => {
  1771	                    let dy = app::event_dy();
  1772	                    let mx = app::event_x() - w.x();
  1773	                    let my = app::event_y() - w.y();
  1774	
  1775	                    // MouseWheel::Down = zoom out, Up = zoom in
  1776	                    let zoom_in = matches!(dy, fltk::app::MouseWheel::Up);
  1777	
  1778	                    let mut st = state.borrow_mut();
  1779	
  1780	                    if app::event_state().contains(fltk::enums::Shortcut::Ctrl.into()) {
  1781	                        // Ctrl+wheel: zoom frequency axis
  1782	                        let focus_t = 1.0 - (my as f32 / w.h() as f32);
  1783	                        let focus_freq = st.view.y_to_freq(focus_t);
  1784	
  1785	                        let zoom_factor = if zoom_in { 1.0 / 1.2 } else { 1.2 };
  1786	                        let range = st.view.visible_freq_range();
  1787	                        let new_range = (range * zoom_factor).clamp(10.0, st.view.data_freq_max_hz);
  1788	
  1789	                        let ratio = focus_t;
  1790	                        st.view.freq_min_hz = (focus_freq - new_range * ratio).max(1.0);
  1791	                        st.view.freq_max_hz = st.view.freq_min_hz + new_range;
  1792	                    } else {
  1793	                        // Wheel: zoom time axis
  1794	                        let focus_t = mx as f64 / w.w() as f64;
  1795	                        let focus_time = st.view.x_to_time(focus_t);
  1796	
  1797	                        let zoom_factor = if zoom_in { 1.0 / 1.2 } else { 1.2 };
  1798	                        let range = st.view.visible_time_range();
  1799	                        let new_range = (range * zoom_factor).clamp(
  1800	                            0.001,
  1801	                            st.view.data_time_max_sec - st.view.data_time_min_sec
  1802	                        );
  1803	
  1804	                        let ratio = focus_t;
  1805	                        st.view.time_min_sec = (focus_time - new_range * ratio).max(st.view.data_time_min_sec);
  1806	                        st.view.time_max_sec = st.view.time_min_sec + new_range;
  1807	                        if st.view.time_max_sec > st.view.data_time_max_sec {
  1808	                            st.view.time_max_sec = st.view.data_time_max_sec;
  1809	                            st.view.time_min_sec = (st.view.time_max_sec - new_range).max(st.view.data_time_min_sec);
  1810	                        }
  1811	                    }
  1812	
  1813	                    st.spec_renderer.invalidate();
  1814	                    st.wave_renderer.invalidate();
  1815	                    drop(st);
  1816	                    spec_display_c.redraw();
  1817	                    waveform_display_c.redraw();
  1818	                    true
  1819	                }
  1820	                Event::Drag => {
  1821	                    // Drag for seeking
  1822	                    let mx = app::event_x() - w.x();
  1823	                    let t = mx as f64 / w.w() as f64;
  1824	                    let st = state.borrow();
  1825	                    let time = st.view.x_to_time(t);
  1826	                    let audio_pos = (time - st.recon_start_time).max(0.0);
  1827	                    st.audio_player.seek_to(audio_pos);
  1828	                    true
  1829	                }
  1830	                _ => false,
  1831	            }
  1832	        });
  1833	    }
  1834	
  1835	    // ── Waveform display ──
  1836	    {
  1837	        let state = state.clone();
  1838	
  1839	        waveform_display.draw(move |w| {
  1840	            if !w.visible_r() || w.w() <= 0 || w.h() <= 0 {
  1841	                return;
  1842	            }
  1843	
  1844	            let Ok(mut st) = state.try_borrow_mut() else { return; };
  1845	
  1846	            // Compute cursor position: playback is relative to recon_start_time
  1847	            let cursor_x = if st.transport.duration_seconds > 0.0 {
  1848	                let playback_time = st.recon_start_time + st.audio_player.get_position_seconds();
  1849	                let t = st.view.time_to_x(playback_time);
  1850	                if t >= 0.0 && t <= 1.0 {
  1851	                    Some((t * w.w() as f64) as i32)
  1852	                } else {
  1853	                    None
  1854	                }
  1855	            } else {
  1856	                None
  1857	            };
  1858	
  1859	            // Clone view and take audio out temporarily to avoid simultaneous mut/immut borrow
  1860	            let view = st.view.clone();
  1861	            let audio_opt = st.reconstructed_audio.take();
  1862	            let recon_start = st.recon_start_time;
  1863	            if let Some(ref audio) = audio_opt {
  1864	                st.wave_renderer.draw(&audio.samples, audio.sample_rate, recon_start, &view, cursor_x, w.x(), w.y(), w.w(), w.h());
  1865	            } else {
  1866	                st.wave_renderer.draw(&[], 44100, 0.0, &view, cursor_x, w.x(), w.y(), w.w(), w.h());
  1867	            }
  1868	            st.reconstructed_audio = audio_opt;
  1869	        });
  1870	    }
  1871	
  1872	    // ── Frequency axis labels ──
  1873	    {
  1874	        let state = state.clone();
  1875	
  1876	        freq_axis.draw(move |w| {
  1877	            if !w.visible_r() || w.w() <= 0 || w.h() <= 0 {
  1878	                return;
  1879	            }
  1880	
  1881	            fltk::draw::set_draw_color(theme::color(theme::BG_DARK));
  1882	            fltk::draw::draw_rectf(w.x(), w.y(), w.w(), w.h());
  1883	
  1884	            let Ok(st) = state.try_borrow() else { return; };
  1885	            if st.spectrogram.is_none() { return; }
  1886	
  1887	            fltk::draw::set_draw_color(theme::color(theme::TEXT_SECONDARY));
  1888	            fltk::draw::set_font(Font::Helvetica, 9);
  1889	
  1890	            // Generate frequency labels
  1891	            let labels: Vec<(f32, &str)> = match st.view.freq_scale {
  1892	                FreqScale::Log => vec![
  1893	                    (20.0, "20"), (50.0, "50"), (100.0, "100"),
  1894	                    (200.0, "200"), (500.0, "500"), (1000.0, "1k"),
  1895	                    (2000.0, "2k"), (5000.0, "5k"), (10000.0, "10k"),
  1896	                    (20000.0, "20k"),
  1897	                ],
  1898	                FreqScale::Linear => {
  1899	                    let range = st.view.visible_freq_range();
  1900	                    let step = if range > 10000.0 { 5000.0 }
  1901	                              else if range > 5000.0 { 2000.0 }
  1902	                              else if range > 2000.0 { 1000.0 }
  1903	                              else if range > 500.0 { 200.0 }
  1904	                              else { 100.0 };
  1905	
  1906	                    let mut labels = Vec::new();
  1907	                    let mut f = (st.view.freq_min_hz / step).ceil() * step;
  1908	                    while f <= st.view.freq_max_hz {
  1909	                        labels.push(f);
  1910	                        f += step;
  1911	                    }
  1912	                    // We need static strings, so just format at draw time
  1913	                    // (use a different approach)
  1914	                    let _ = labels;
  1915	                    vec![] // Will handle below
  1916	                }
  1917	            };
  1918	
  1919	            if !labels.is_empty() {
  1920	                for (freq, label) in &labels {
  1921	                    if *freq < st.view.freq_min_hz || *freq > st.view.freq_max_hz {
  1922	                        continue;
  1923	                    }
  1924	                    let t = st.view.freq_to_y(*freq);
  1925	                    let py = w.y() + w.h() - (t * w.h() as f32) as i32;
  1926	                    fltk::draw::draw_text(label, w.x() + 2, py + 3);
  1927	
  1928	                    // Tick mark
  1929	                    fltk::draw::set_draw_color(theme::color(theme::BORDER));
  1930	                    fltk::draw::draw_line(w.x() + w.w() - 4, py, w.x() + w.w(), py);
  1931	                    fltk::draw::set_draw_color(theme::color(theme::TEXT_SECONDARY));
  1932	                }
  1933	            }
  1934	
  1935	            // Draw boundary lines for recon freq range
  1936	            fltk::draw::set_draw_color(fltk::enums::Color::from_hex(0xf9e2af)); // accent yellow
  1937	            let recon_min_t = st.view.freq_to_y(st.view.recon_freq_min_hz);
  1938	            if recon_min_t > 0.01 && recon_min_t < 0.99 {
  1939	                let py = w.y() + w.h() - (recon_min_t * w.h() as f32) as i32;
  1940	                fltk::draw::set_line_style(fltk::draw::LineStyle::Dash, 1);
  1941	                fltk::draw::draw_line(w.x(), py, w.x() + w.w(), py);
  1942	                fltk::draw::set_line_style(fltk::draw::LineStyle::Solid, 0);
  1943	            }
  1944	            let recon_max_t = st.view.freq_to_y(st.view.recon_freq_max_hz);
  1945	            if recon_max_t > 0.01 && recon_max_t < 0.99 {
  1946	                let py = w.y() + w.h() - (recon_max_t * w.h() as f32) as i32;
  1947	                fltk::draw::set_line_style(fltk::draw::LineStyle::Dash, 1);
  1948	                fltk::draw::draw_line(w.x(), py, w.x() + w.w(), py);
  1949	                fltk::draw::set_line_style(fltk::draw::LineStyle::Solid, 0);
  1950	            }
  1951	
  1952	            if labels.is_empty() {
  1953	                // Linear mode: format numbers dynamically
  1954	                let range = st.view.visible_freq_range();
  1955	                let step = if range > 10000.0 { 5000.0 }
  1956	                          else if range > 5000.0 { 2000.0 }
  1957	                          else if range > 2000.0 { 1000.0 }
  1958	                          else if range > 500.0 { 200.0 }
  1959	                          else { 100.0 };
  1960	
  1961	                let mut f = (st.view.freq_min_hz / step).ceil() * step;
  1962	                while f <= st.view.freq_max_hz {
  1963	                    let t = st.view.freq_to_y(f);
  1964	                    let py = w.y() + w.h() - (t * w.h() as f32) as i32;
  1965	                    let label = if f >= 1000.0 {
  1966	                        format!("{}k", (f / 1000.0) as i32)
  1967	                    } else {
  1968	                        format!("{}", f as i32)
  1969	                    };
  1970	                    fltk::draw::draw_text(&label, w.x() + 2, py + 3);
  1971	
  1972	                    fltk::draw::set_draw_color(theme::color(theme::BORDER));
  1973	                    fltk::draw::draw_line(w.x() + w.w() - 4, py, w.x() + w.w(), py);
  1974	                    fltk::draw::set_draw_color(theme::color(theme::TEXT_SECONDARY));
  1975	
  1976	                    f += step;
  1977	                }
  1978	            }
  1979	        });
  1980	    }
  1981	
  1982	    // ── Time axis labels ──
  1983	    {
  1984	        let state = state.clone();
  1985	
  1986	        time_axis.draw(move |w| {
  1987	            if !w.visible_r() || w.w() <= 0 || w.h() <= 0 {
  1988	                return;
  1989	            }
  1990	
  1991	            fltk::draw::set_draw_color(theme::color(theme::BG_DARK));
  1992	            fltk::draw::draw_rectf(w.x(), w.y(), w.w(), w.h());
  1993	
  1994	            let Ok(st) = state.try_borrow() else { return; };
  1995	            if st.spectrogram.is_none() { return; }
  1996	
  1997	            fltk::draw::set_draw_color(theme::color(theme::TEXT_SECONDARY));
  1998	            fltk::draw::set_font(Font::Helvetica, 9);
  1999	
  2000	            let range = st.view.visible_time_range();
  